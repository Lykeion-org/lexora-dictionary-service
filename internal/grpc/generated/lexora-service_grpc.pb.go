// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: lexora-service.proto

package lexora

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LexoraService_LookUpReferent_FullMethodName                 = "/lexora.LexoraService/LookUpReferent"
	LexoraService_LookupSymbol_FullMethodName                   = "/lexora.LexoraService/LookupSymbol"
	LexoraService_LookupWord_FullMethodName                     = "/lexora.LexoraService/LookupWord"
	LexoraService_AnalyzeText_FullMethodName                    = "/lexora.LexoraService/AnalyzeText"
	LexoraService_Ping_FullMethodName                           = "/lexora.LexoraService/Ping"
	LexoraService_GetLanguageDefinitions_FullMethodName         = "/lexora.LexoraService/GetLanguageDefinitions"
	LexoraService_GetSymbolDefinitions_FullMethodName           = "/lexora.LexoraService/GetSymbolDefinitions"
	LexoraService_GetWordAttributeDefinitions_FullMethodName    = "/lexora.LexoraService/GetWordAttributeDefinitions"
	LexoraService_GetReferent_FullMethodName                    = "/lexora.LexoraService/GetReferent"
	LexoraService_GetSymbol_FullMethodName                      = "/lexora.LexoraService/GetSymbol"
	LexoraService_GetWord_FullMethodName                        = "/lexora.LexoraService/GetWord"
	LexoraService_ListReferents_FullMethodName                  = "/lexora.LexoraService/ListReferents"
	LexoraService_FindReferents_FullMethodName                  = "/lexora.LexoraService/FindReferents"
	LexoraService_CreateReferent_FullMethodName                 = "/lexora.LexoraService/CreateReferent"
	LexoraService_CreateSymbol_FullMethodName                   = "/lexora.LexoraService/CreateSymbol"
	LexoraService_CreateWord_FullMethodName                     = "/lexora.LexoraService/CreateWord"
	LexoraService_UpdateReferent_FullMethodName                 = "/lexora.LexoraService/UpdateReferent"
	LexoraService_UpdateSymbol_FullMethodName                   = "/lexora.LexoraService/UpdateSymbol"
	LexoraService_UpdateWord_FullMethodName                     = "/lexora.LexoraService/UpdateWord"
	LexoraService_DeleteReferent_FullMethodName                 = "/lexora.LexoraService/DeleteReferent"
	LexoraService_DeleteSymbol_FullMethodName                   = "/lexora.LexoraService/DeleteSymbol"
	LexoraService_DeleteWord_FullMethodName                     = "/lexora.LexoraService/DeleteWord"
	LexoraService_LinkSymbolToReferent_FullMethodName           = "/lexora.LexoraService/LinkSymbolToReferent"
	LexoraService_LinkWordToSymbol_FullMethodName               = "/lexora.LexoraService/LinkWordToSymbol"
	LexoraService_SetSymbolLemma_FullMethodName                 = "/lexora.LexoraService/SetSymbolLemma"
	LexoraService_AnalyzeTextAndAddToSuggestions_FullMethodName = "/lexora.LexoraService/AnalyzeTextAndAddToSuggestions"
	LexoraService_ApproveSuggestion_FullMethodName              = "/lexora.LexoraService/ApproveSuggestion"
	LexoraService_UpdateWordSuggestion_FullMethodName           = "/lexora.LexoraService/UpdateWordSuggestion"
)

// LexoraServiceClient is the client API for LexoraService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LexoraServiceClient interface {
	// ******************************* CLIENT API *******************************
	LookUpReferent(ctx context.Context, in *LookUpReferentRequest, opts ...grpc.CallOption) (*LookUpReferentResponse, error)
	LookupSymbol(ctx context.Context, in *LookupSymbolRequest, opts ...grpc.CallOption) (*LookupSymbolResponse, error)
	LookupWord(ctx context.Context, in *LookupWordRequest, opts ...grpc.CallOption) (*LookupWordResponse, error)
	AnalyzeText(ctx context.Context, in *AnalyzeTextRequest, opts ...grpc.CallOption) (*AnalyzeTextResponse, error)
	// ******************************* ADMIN API *******************************
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	// *ENUM Definitions
	GetLanguageDefinitions(ctx context.Context, in *GetLanguageDefinitionsRequest, opts ...grpc.CallOption) (*GetLanguageResponse, error)
	GetSymbolDefinitions(ctx context.Context, in *GetSymbolDefinitionsRequest, opts ...grpc.CallOption) (*GetSymbolDefinitionsResponse, error)
	GetWordAttributeDefinitions(ctx context.Context, in *GetWordAttributeDefinitionsRequest, opts ...grpc.CallOption) (*GetWordAttributeDefinitionsResponse, error)
	// *Dictionary CRUD operations (these are to be forwarded to the dictionary service)
	// READ
	GetReferent(ctx context.Context, in *GetReferentRequest, opts ...grpc.CallOption) (*Referent, error)
	GetSymbol(ctx context.Context, in *GetSymbolRequest, opts ...grpc.CallOption) (*Symbol, error)
	GetWord(ctx context.Context, in *GetWordRequest, opts ...grpc.CallOption) (*Word, error)
	ListReferents(ctx context.Context, in *ListReferentsRequest, opts ...grpc.CallOption) (*ListReferentsResponse, error)
	FindReferents(ctx context.Context, in *FindReferentsRequest, opts ...grpc.CallOption) (*FindReferentsResponse, error)
	// CREATE
	CreateReferent(ctx context.Context, in *CreateReferentRequest, opts ...grpc.CallOption) (*Referent, error)
	CreateSymbol(ctx context.Context, in *CreateSymbolRequest, opts ...grpc.CallOption) (*Symbol, error)
	CreateWord(ctx context.Context, in *CreateWordRequest, opts ...grpc.CallOption) (*Word, error)
	// UPDATE
	UpdateReferent(ctx context.Context, in *UpdateReferentRequest, opts ...grpc.CallOption) (*Referent, error)
	UpdateSymbol(ctx context.Context, in *UpdateSymbolRequest, opts ...grpc.CallOption) (*Symbol, error)
	UpdateWord(ctx context.Context, in *UpdateWordRequest, opts ...grpc.CallOption) (*Word, error)
	// DELETE
	DeleteReferent(ctx context.Context, in *DeleteReferentRequest, opts ...grpc.CallOption) (*Referent, error)
	DeleteSymbol(ctx context.Context, in *DeleteSymbolRequest, opts ...grpc.CallOption) (*Symbol, error)
	DeleteWord(ctx context.Context, in *DeleteWordRequest, opts ...grpc.CallOption) (*Word, error)
	// LINKING OPERATIONS
	LinkSymbolToReferent(ctx context.Context, in *LinkSymbolToReferentRequest, opts ...grpc.CallOption) (*LinkSymbolToReferentResponse, error)
	LinkWordToSymbol(ctx context.Context, in *LinkWordToSymbolRequest, opts ...grpc.CallOption) (*LinkWordToSymbolResponse, error)
	SetSymbolLemma(ctx context.Context, in *SetSymbolLemmaRequest, opts ...grpc.CallOption) (*SetSymbolLemmaResponse, error)
	// *NLP OPERATIONS
	AnalyzeTextAndAddToSuggestions(ctx context.Context, in *AnalyzeTextAndAddToSuggestionsRequest, opts ...grpc.CallOption) (*AnalyzeTextAndAddToSuggestionsResponse, error)
	ApproveSuggestion(ctx context.Context, in *ApproveSuggestionRequest, opts ...grpc.CallOption) (*ApproveSuggestionResponse, error)
	UpdateWordSuggestion(ctx context.Context, in *UpdateWordSuggestionRequest, opts ...grpc.CallOption) (*UpdateWordRequestResponse, error)
}

type lexoraServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLexoraServiceClient(cc grpc.ClientConnInterface) LexoraServiceClient {
	return &lexoraServiceClient{cc}
}

func (c *lexoraServiceClient) LookUpReferent(ctx context.Context, in *LookUpReferentRequest, opts ...grpc.CallOption) (*LookUpReferentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LookUpReferentResponse)
	err := c.cc.Invoke(ctx, LexoraService_LookUpReferent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) LookupSymbol(ctx context.Context, in *LookupSymbolRequest, opts ...grpc.CallOption) (*LookupSymbolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LookupSymbolResponse)
	err := c.cc.Invoke(ctx, LexoraService_LookupSymbol_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) LookupWord(ctx context.Context, in *LookupWordRequest, opts ...grpc.CallOption) (*LookupWordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LookupWordResponse)
	err := c.cc.Invoke(ctx, LexoraService_LookupWord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) AnalyzeText(ctx context.Context, in *AnalyzeTextRequest, opts ...grpc.CallOption) (*AnalyzeTextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnalyzeTextResponse)
	err := c.cc.Invoke(ctx, LexoraService_AnalyzeText_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, LexoraService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) GetLanguageDefinitions(ctx context.Context, in *GetLanguageDefinitionsRequest, opts ...grpc.CallOption) (*GetLanguageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLanguageResponse)
	err := c.cc.Invoke(ctx, LexoraService_GetLanguageDefinitions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) GetSymbolDefinitions(ctx context.Context, in *GetSymbolDefinitionsRequest, opts ...grpc.CallOption) (*GetSymbolDefinitionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSymbolDefinitionsResponse)
	err := c.cc.Invoke(ctx, LexoraService_GetSymbolDefinitions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) GetWordAttributeDefinitions(ctx context.Context, in *GetWordAttributeDefinitionsRequest, opts ...grpc.CallOption) (*GetWordAttributeDefinitionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWordAttributeDefinitionsResponse)
	err := c.cc.Invoke(ctx, LexoraService_GetWordAttributeDefinitions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) GetReferent(ctx context.Context, in *GetReferentRequest, opts ...grpc.CallOption) (*Referent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Referent)
	err := c.cc.Invoke(ctx, LexoraService_GetReferent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) GetSymbol(ctx context.Context, in *GetSymbolRequest, opts ...grpc.CallOption) (*Symbol, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Symbol)
	err := c.cc.Invoke(ctx, LexoraService_GetSymbol_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) GetWord(ctx context.Context, in *GetWordRequest, opts ...grpc.CallOption) (*Word, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Word)
	err := c.cc.Invoke(ctx, LexoraService_GetWord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) ListReferents(ctx context.Context, in *ListReferentsRequest, opts ...grpc.CallOption) (*ListReferentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReferentsResponse)
	err := c.cc.Invoke(ctx, LexoraService_ListReferents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) FindReferents(ctx context.Context, in *FindReferentsRequest, opts ...grpc.CallOption) (*FindReferentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindReferentsResponse)
	err := c.cc.Invoke(ctx, LexoraService_FindReferents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) CreateReferent(ctx context.Context, in *CreateReferentRequest, opts ...grpc.CallOption) (*Referent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Referent)
	err := c.cc.Invoke(ctx, LexoraService_CreateReferent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) CreateSymbol(ctx context.Context, in *CreateSymbolRequest, opts ...grpc.CallOption) (*Symbol, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Symbol)
	err := c.cc.Invoke(ctx, LexoraService_CreateSymbol_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) CreateWord(ctx context.Context, in *CreateWordRequest, opts ...grpc.CallOption) (*Word, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Word)
	err := c.cc.Invoke(ctx, LexoraService_CreateWord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) UpdateReferent(ctx context.Context, in *UpdateReferentRequest, opts ...grpc.CallOption) (*Referent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Referent)
	err := c.cc.Invoke(ctx, LexoraService_UpdateReferent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) UpdateSymbol(ctx context.Context, in *UpdateSymbolRequest, opts ...grpc.CallOption) (*Symbol, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Symbol)
	err := c.cc.Invoke(ctx, LexoraService_UpdateSymbol_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) UpdateWord(ctx context.Context, in *UpdateWordRequest, opts ...grpc.CallOption) (*Word, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Word)
	err := c.cc.Invoke(ctx, LexoraService_UpdateWord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) DeleteReferent(ctx context.Context, in *DeleteReferentRequest, opts ...grpc.CallOption) (*Referent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Referent)
	err := c.cc.Invoke(ctx, LexoraService_DeleteReferent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) DeleteSymbol(ctx context.Context, in *DeleteSymbolRequest, opts ...grpc.CallOption) (*Symbol, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Symbol)
	err := c.cc.Invoke(ctx, LexoraService_DeleteSymbol_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) DeleteWord(ctx context.Context, in *DeleteWordRequest, opts ...grpc.CallOption) (*Word, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Word)
	err := c.cc.Invoke(ctx, LexoraService_DeleteWord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) LinkSymbolToReferent(ctx context.Context, in *LinkSymbolToReferentRequest, opts ...grpc.CallOption) (*LinkSymbolToReferentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LinkSymbolToReferentResponse)
	err := c.cc.Invoke(ctx, LexoraService_LinkSymbolToReferent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) LinkWordToSymbol(ctx context.Context, in *LinkWordToSymbolRequest, opts ...grpc.CallOption) (*LinkWordToSymbolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LinkWordToSymbolResponse)
	err := c.cc.Invoke(ctx, LexoraService_LinkWordToSymbol_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) SetSymbolLemma(ctx context.Context, in *SetSymbolLemmaRequest, opts ...grpc.CallOption) (*SetSymbolLemmaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetSymbolLemmaResponse)
	err := c.cc.Invoke(ctx, LexoraService_SetSymbolLemma_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) AnalyzeTextAndAddToSuggestions(ctx context.Context, in *AnalyzeTextAndAddToSuggestionsRequest, opts ...grpc.CallOption) (*AnalyzeTextAndAddToSuggestionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnalyzeTextAndAddToSuggestionsResponse)
	err := c.cc.Invoke(ctx, LexoraService_AnalyzeTextAndAddToSuggestions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) ApproveSuggestion(ctx context.Context, in *ApproveSuggestionRequest, opts ...grpc.CallOption) (*ApproveSuggestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApproveSuggestionResponse)
	err := c.cc.Invoke(ctx, LexoraService_ApproveSuggestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lexoraServiceClient) UpdateWordSuggestion(ctx context.Context, in *UpdateWordSuggestionRequest, opts ...grpc.CallOption) (*UpdateWordRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateWordRequestResponse)
	err := c.cc.Invoke(ctx, LexoraService_UpdateWordSuggestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LexoraServiceServer is the server API for LexoraService service.
// All implementations must embed UnimplementedLexoraServiceServer
// for forward compatibility.
type LexoraServiceServer interface {
	// ******************************* CLIENT API *******************************
	LookUpReferent(context.Context, *LookUpReferentRequest) (*LookUpReferentResponse, error)
	LookupSymbol(context.Context, *LookupSymbolRequest) (*LookupSymbolResponse, error)
	LookupWord(context.Context, *LookupWordRequest) (*LookupWordResponse, error)
	AnalyzeText(context.Context, *AnalyzeTextRequest) (*AnalyzeTextResponse, error)
	// ******************************* ADMIN API *******************************
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	// *ENUM Definitions
	GetLanguageDefinitions(context.Context, *GetLanguageDefinitionsRequest) (*GetLanguageResponse, error)
	GetSymbolDefinitions(context.Context, *GetSymbolDefinitionsRequest) (*GetSymbolDefinitionsResponse, error)
	GetWordAttributeDefinitions(context.Context, *GetWordAttributeDefinitionsRequest) (*GetWordAttributeDefinitionsResponse, error)
	// *Dictionary CRUD operations (these are to be forwarded to the dictionary service)
	// READ
	GetReferent(context.Context, *GetReferentRequest) (*Referent, error)
	GetSymbol(context.Context, *GetSymbolRequest) (*Symbol, error)
	GetWord(context.Context, *GetWordRequest) (*Word, error)
	ListReferents(context.Context, *ListReferentsRequest) (*ListReferentsResponse, error)
	FindReferents(context.Context, *FindReferentsRequest) (*FindReferentsResponse, error)
	// CREATE
	CreateReferent(context.Context, *CreateReferentRequest) (*Referent, error)
	CreateSymbol(context.Context, *CreateSymbolRequest) (*Symbol, error)
	CreateWord(context.Context, *CreateWordRequest) (*Word, error)
	// UPDATE
	UpdateReferent(context.Context, *UpdateReferentRequest) (*Referent, error)
	UpdateSymbol(context.Context, *UpdateSymbolRequest) (*Symbol, error)
	UpdateWord(context.Context, *UpdateWordRequest) (*Word, error)
	// DELETE
	DeleteReferent(context.Context, *DeleteReferentRequest) (*Referent, error)
	DeleteSymbol(context.Context, *DeleteSymbolRequest) (*Symbol, error)
	DeleteWord(context.Context, *DeleteWordRequest) (*Word, error)
	// LINKING OPERATIONS
	LinkSymbolToReferent(context.Context, *LinkSymbolToReferentRequest) (*LinkSymbolToReferentResponse, error)
	LinkWordToSymbol(context.Context, *LinkWordToSymbolRequest) (*LinkWordToSymbolResponse, error)
	SetSymbolLemma(context.Context, *SetSymbolLemmaRequest) (*SetSymbolLemmaResponse, error)
	// *NLP OPERATIONS
	AnalyzeTextAndAddToSuggestions(context.Context, *AnalyzeTextAndAddToSuggestionsRequest) (*AnalyzeTextAndAddToSuggestionsResponse, error)
	ApproveSuggestion(context.Context, *ApproveSuggestionRequest) (*ApproveSuggestionResponse, error)
	UpdateWordSuggestion(context.Context, *UpdateWordSuggestionRequest) (*UpdateWordRequestResponse, error)
	mustEmbedUnimplementedLexoraServiceServer()
}

// UnimplementedLexoraServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLexoraServiceServer struct{}

func (UnimplementedLexoraServiceServer) LookUpReferent(context.Context, *LookUpReferentRequest) (*LookUpReferentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookUpReferent not implemented")
}
func (UnimplementedLexoraServiceServer) LookupSymbol(context.Context, *LookupSymbolRequest) (*LookupSymbolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupSymbol not implemented")
}
func (UnimplementedLexoraServiceServer) LookupWord(context.Context, *LookupWordRequest) (*LookupWordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupWord not implemented")
}
func (UnimplementedLexoraServiceServer) AnalyzeText(context.Context, *AnalyzeTextRequest) (*AnalyzeTextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnalyzeText not implemented")
}
func (UnimplementedLexoraServiceServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedLexoraServiceServer) GetLanguageDefinitions(context.Context, *GetLanguageDefinitionsRequest) (*GetLanguageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLanguageDefinitions not implemented")
}
func (UnimplementedLexoraServiceServer) GetSymbolDefinitions(context.Context, *GetSymbolDefinitionsRequest) (*GetSymbolDefinitionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSymbolDefinitions not implemented")
}
func (UnimplementedLexoraServiceServer) GetWordAttributeDefinitions(context.Context, *GetWordAttributeDefinitionsRequest) (*GetWordAttributeDefinitionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWordAttributeDefinitions not implemented")
}
func (UnimplementedLexoraServiceServer) GetReferent(context.Context, *GetReferentRequest) (*Referent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReferent not implemented")
}
func (UnimplementedLexoraServiceServer) GetSymbol(context.Context, *GetSymbolRequest) (*Symbol, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSymbol not implemented")
}
func (UnimplementedLexoraServiceServer) GetWord(context.Context, *GetWordRequest) (*Word, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWord not implemented")
}
func (UnimplementedLexoraServiceServer) ListReferents(context.Context, *ListReferentsRequest) (*ListReferentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReferents not implemented")
}
func (UnimplementedLexoraServiceServer) FindReferents(context.Context, *FindReferentsRequest) (*FindReferentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindReferents not implemented")
}
func (UnimplementedLexoraServiceServer) CreateReferent(context.Context, *CreateReferentRequest) (*Referent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReferent not implemented")
}
func (UnimplementedLexoraServiceServer) CreateSymbol(context.Context, *CreateSymbolRequest) (*Symbol, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSymbol not implemented")
}
func (UnimplementedLexoraServiceServer) CreateWord(context.Context, *CreateWordRequest) (*Word, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWord not implemented")
}
func (UnimplementedLexoraServiceServer) UpdateReferent(context.Context, *UpdateReferentRequest) (*Referent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReferent not implemented")
}
func (UnimplementedLexoraServiceServer) UpdateSymbol(context.Context, *UpdateSymbolRequest) (*Symbol, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSymbol not implemented")
}
func (UnimplementedLexoraServiceServer) UpdateWord(context.Context, *UpdateWordRequest) (*Word, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWord not implemented")
}
func (UnimplementedLexoraServiceServer) DeleteReferent(context.Context, *DeleteReferentRequest) (*Referent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReferent not implemented")
}
func (UnimplementedLexoraServiceServer) DeleteSymbol(context.Context, *DeleteSymbolRequest) (*Symbol, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSymbol not implemented")
}
func (UnimplementedLexoraServiceServer) DeleteWord(context.Context, *DeleteWordRequest) (*Word, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWord not implemented")
}
func (UnimplementedLexoraServiceServer) LinkSymbolToReferent(context.Context, *LinkSymbolToReferentRequest) (*LinkSymbolToReferentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkSymbolToReferent not implemented")
}
func (UnimplementedLexoraServiceServer) LinkWordToSymbol(context.Context, *LinkWordToSymbolRequest) (*LinkWordToSymbolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkWordToSymbol not implemented")
}
func (UnimplementedLexoraServiceServer) SetSymbolLemma(context.Context, *SetSymbolLemmaRequest) (*SetSymbolLemmaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSymbolLemma not implemented")
}
func (UnimplementedLexoraServiceServer) AnalyzeTextAndAddToSuggestions(context.Context, *AnalyzeTextAndAddToSuggestionsRequest) (*AnalyzeTextAndAddToSuggestionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnalyzeTextAndAddToSuggestions not implemented")
}
func (UnimplementedLexoraServiceServer) ApproveSuggestion(context.Context, *ApproveSuggestionRequest) (*ApproveSuggestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveSuggestion not implemented")
}
func (UnimplementedLexoraServiceServer) UpdateWordSuggestion(context.Context, *UpdateWordSuggestionRequest) (*UpdateWordRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWordSuggestion not implemented")
}
func (UnimplementedLexoraServiceServer) mustEmbedUnimplementedLexoraServiceServer() {}
func (UnimplementedLexoraServiceServer) testEmbeddedByValue()                       {}

// UnsafeLexoraServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LexoraServiceServer will
// result in compilation errors.
type UnsafeLexoraServiceServer interface {
	mustEmbedUnimplementedLexoraServiceServer()
}

func RegisterLexoraServiceServer(s grpc.ServiceRegistrar, srv LexoraServiceServer) {
	// If the following call pancis, it indicates UnimplementedLexoraServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LexoraService_ServiceDesc, srv)
}

func _LexoraService_LookUpReferent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookUpReferentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).LookUpReferent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_LookUpReferent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).LookUpReferent(ctx, req.(*LookUpReferentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_LookupSymbol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupSymbolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).LookupSymbol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_LookupSymbol_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).LookupSymbol(ctx, req.(*LookupSymbolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_LookupWord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupWordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).LookupWord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_LookupWord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).LookupWord(ctx, req.(*LookupWordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_AnalyzeText_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyzeTextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).AnalyzeText(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_AnalyzeText_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).AnalyzeText(ctx, req.(*AnalyzeTextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_GetLanguageDefinitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLanguageDefinitionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).GetLanguageDefinitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_GetLanguageDefinitions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).GetLanguageDefinitions(ctx, req.(*GetLanguageDefinitionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_GetSymbolDefinitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSymbolDefinitionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).GetSymbolDefinitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_GetSymbolDefinitions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).GetSymbolDefinitions(ctx, req.(*GetSymbolDefinitionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_GetWordAttributeDefinitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWordAttributeDefinitionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).GetWordAttributeDefinitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_GetWordAttributeDefinitions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).GetWordAttributeDefinitions(ctx, req.(*GetWordAttributeDefinitionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_GetReferent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReferentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).GetReferent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_GetReferent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).GetReferent(ctx, req.(*GetReferentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_GetSymbol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSymbolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).GetSymbol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_GetSymbol_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).GetSymbol(ctx, req.(*GetSymbolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_GetWord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).GetWord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_GetWord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).GetWord(ctx, req.(*GetWordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_ListReferents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReferentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).ListReferents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_ListReferents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).ListReferents(ctx, req.(*ListReferentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_FindReferents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindReferentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).FindReferents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_FindReferents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).FindReferents(ctx, req.(*FindReferentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_CreateReferent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReferentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).CreateReferent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_CreateReferent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).CreateReferent(ctx, req.(*CreateReferentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_CreateSymbol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSymbolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).CreateSymbol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_CreateSymbol_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).CreateSymbol(ctx, req.(*CreateSymbolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_CreateWord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).CreateWord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_CreateWord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).CreateWord(ctx, req.(*CreateWordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_UpdateReferent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReferentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).UpdateReferent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_UpdateReferent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).UpdateReferent(ctx, req.(*UpdateReferentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_UpdateSymbol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSymbolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).UpdateSymbol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_UpdateSymbol_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).UpdateSymbol(ctx, req.(*UpdateSymbolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_UpdateWord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).UpdateWord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_UpdateWord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).UpdateWord(ctx, req.(*UpdateWordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_DeleteReferent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReferentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).DeleteReferent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_DeleteReferent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).DeleteReferent(ctx, req.(*DeleteReferentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_DeleteSymbol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSymbolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).DeleteSymbol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_DeleteSymbol_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).DeleteSymbol(ctx, req.(*DeleteSymbolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_DeleteWord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).DeleteWord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_DeleteWord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).DeleteWord(ctx, req.(*DeleteWordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_LinkSymbolToReferent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkSymbolToReferentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).LinkSymbolToReferent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_LinkSymbolToReferent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).LinkSymbolToReferent(ctx, req.(*LinkSymbolToReferentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_LinkWordToSymbol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LinkWordToSymbolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).LinkWordToSymbol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_LinkWordToSymbol_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).LinkWordToSymbol(ctx, req.(*LinkWordToSymbolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_SetSymbolLemma_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSymbolLemmaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).SetSymbolLemma(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_SetSymbolLemma_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).SetSymbolLemma(ctx, req.(*SetSymbolLemmaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_AnalyzeTextAndAddToSuggestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyzeTextAndAddToSuggestionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).AnalyzeTextAndAddToSuggestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_AnalyzeTextAndAddToSuggestions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).AnalyzeTextAndAddToSuggestions(ctx, req.(*AnalyzeTextAndAddToSuggestionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_ApproveSuggestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveSuggestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).ApproveSuggestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_ApproveSuggestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).ApproveSuggestion(ctx, req.(*ApproveSuggestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LexoraService_UpdateWordSuggestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWordSuggestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LexoraServiceServer).UpdateWordSuggestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LexoraService_UpdateWordSuggestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LexoraServiceServer).UpdateWordSuggestion(ctx, req.(*UpdateWordSuggestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LexoraService_ServiceDesc is the grpc.ServiceDesc for LexoraService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LexoraService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lexora.LexoraService",
	HandlerType: (*LexoraServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LookUpReferent",
			Handler:    _LexoraService_LookUpReferent_Handler,
		},
		{
			MethodName: "LookupSymbol",
			Handler:    _LexoraService_LookupSymbol_Handler,
		},
		{
			MethodName: "LookupWord",
			Handler:    _LexoraService_LookupWord_Handler,
		},
		{
			MethodName: "AnalyzeText",
			Handler:    _LexoraService_AnalyzeText_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _LexoraService_Ping_Handler,
		},
		{
			MethodName: "GetLanguageDefinitions",
			Handler:    _LexoraService_GetLanguageDefinitions_Handler,
		},
		{
			MethodName: "GetSymbolDefinitions",
			Handler:    _LexoraService_GetSymbolDefinitions_Handler,
		},
		{
			MethodName: "GetWordAttributeDefinitions",
			Handler:    _LexoraService_GetWordAttributeDefinitions_Handler,
		},
		{
			MethodName: "GetReferent",
			Handler:    _LexoraService_GetReferent_Handler,
		},
		{
			MethodName: "GetSymbol",
			Handler:    _LexoraService_GetSymbol_Handler,
		},
		{
			MethodName: "GetWord",
			Handler:    _LexoraService_GetWord_Handler,
		},
		{
			MethodName: "ListReferents",
			Handler:    _LexoraService_ListReferents_Handler,
		},
		{
			MethodName: "FindReferents",
			Handler:    _LexoraService_FindReferents_Handler,
		},
		{
			MethodName: "CreateReferent",
			Handler:    _LexoraService_CreateReferent_Handler,
		},
		{
			MethodName: "CreateSymbol",
			Handler:    _LexoraService_CreateSymbol_Handler,
		},
		{
			MethodName: "CreateWord",
			Handler:    _LexoraService_CreateWord_Handler,
		},
		{
			MethodName: "UpdateReferent",
			Handler:    _LexoraService_UpdateReferent_Handler,
		},
		{
			MethodName: "UpdateSymbol",
			Handler:    _LexoraService_UpdateSymbol_Handler,
		},
		{
			MethodName: "UpdateWord",
			Handler:    _LexoraService_UpdateWord_Handler,
		},
		{
			MethodName: "DeleteReferent",
			Handler:    _LexoraService_DeleteReferent_Handler,
		},
		{
			MethodName: "DeleteSymbol",
			Handler:    _LexoraService_DeleteSymbol_Handler,
		},
		{
			MethodName: "DeleteWord",
			Handler:    _LexoraService_DeleteWord_Handler,
		},
		{
			MethodName: "LinkSymbolToReferent",
			Handler:    _LexoraService_LinkSymbolToReferent_Handler,
		},
		{
			MethodName: "LinkWordToSymbol",
			Handler:    _LexoraService_LinkWordToSymbol_Handler,
		},
		{
			MethodName: "SetSymbolLemma",
			Handler:    _LexoraService_SetSymbolLemma_Handler,
		},
		{
			MethodName: "AnalyzeTextAndAddToSuggestions",
			Handler:    _LexoraService_AnalyzeTextAndAddToSuggestions_Handler,
		},
		{
			MethodName: "ApproveSuggestion",
			Handler:    _LexoraService_ApproveSuggestion_Handler,
		},
		{
			MethodName: "UpdateWordSuggestion",
			Handler:    _LexoraService_UpdateWordSuggestion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lexora-service.proto",
}
